<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Cosine-Sine Decomposition</title>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="icon" type="image/svg+xml" href="./assets/favicon.svg">
    <link rel="stylesheet" href="./assets/css/index.css">
</head>

<body>
    <div class="main-container">
        <div class="header">
            <h1>Cosine-Sine Decomposition</h1>
            <p>This shows how a <span class="phase-shifted">phase-shifted cosine</span> can be decomposed into the sum
                of two
                components:
                a <span class="cosine-component">scaled cosine</span> and a <span class="sine-component">scaled
                    sine</span>. The <span class="decomposed-sum">red dashed line</span>
                proves they sum to the original.</p>
            <p><strong>Formula:</strong> <span class="phase-shifted">cos(t + Φ)</span> = <span
                    class="cosine-component">cos(Φ)cos(t)</span> - <span class="sine-component">sin(Φ)sin(t)</span></p>
        </div>

        <div class="charts-section">
            <div class="left-charts">
                <div class="chart-item">
                    <h2 id="phaseShiftedCosineTitle">cos(t + Φ)</h2>
                    <div class="chart-container">
                        <canvas id="phaseShiftedCosineChart"></canvas>
                    </div>
                </div>
                <div class="complex-chart-item">
                    <h2 id="complexPlaneTitle">Complex Representation</h2>
                    <p style="font-size: 0.8em; margin: 0 0 5px 0;">e^(iΦ) = <span
                            class="cosine-component">cos(Φ)</span> + i·<span class="sine-component">sin(Φ)</span></p>
                    <div class="chart-container">
                        <canvas id="complexPlaneChart"></canvas>
                    </div>
                </div>
                <div class="chart-item">
                    <h2 id="nonPhaseShiftedCosineTitle">cos(Φ)cos(t)</h2>
                    <div class="chart-container">
                        <canvas id="nonPhaseShiftedCosineChart"></canvas>
                    </div>
                </div>
                <div class="chart-item">
                    <h2 id="sineWaveTitle">-sin(Φ)sin(t)</h2>
                    <div class="chart-container">
                        <canvas id="sineWaveChart"></canvas>
                    </div>
                </div>
            </div>
            <div class="right-charts">
                <!-- Empty - all charts moved to left column for better mobile ordering -->
            </div>
        </div>

        <div class="controls">
            <div style="margin-bottom: 10px;">
                <label for="phaseShiftSlider">Phase Shift (Φ): </label>
                <input type="range" id="phaseShiftSlider" min="0" value="0.785">
                <span id="phaseShiftValue">π/4</span>
                <span style="font-size: 0.8em; margin-left: 10px; color: #666;">← Drag to see how the decomposition
                    changes</span>
            </div>
        </div>
    </div>

    <script>
        const labels = Array.from({ length: 100 }, (_, i) => -Math.PI + (i * (2 * Math.PI / 99)));
        const phaseShift = Math.PI / 4;

        // Store chart instances and user preferences
        let charts = {};
        let legendVisible = {
            'phaseShiftedCosineChart': true,
            'nonPhaseShiftedCosineChart': false,
            'sineWaveChart': false,
            'complexPlaneChart': false
        };
        let datasetVisibility = {};

        const phaseShiftSlider = document.getElementById('phaseShiftSlider');
        const phaseShiftValue = document.getElementById('phaseShiftValue');

        // Set the slider maximum to exactly 2π and step to π/100
        phaseStep = Math.PI / 100;
        phaseShiftSlider.step = phaseStep;
        phaseShiftSlider.max = 2 * Math.PI + phaseStep; // Add a small step to include 2π
        function formatPiLabels(labels) {
            return labels.map(label => {
                const multiple = (label / Math.PI).toFixed(2);
                if (multiple == 0) return '0';
                if (multiple == 1) return 'π';
                if (multiple == -1) return '-π';
                return `${multiple}π`;
            });
        }

        const formattedLabels = formatPiLabels(labels);

        function formatPhaseShift(phaseShift) {
            const multiple = (phaseShift / Math.PI);
            return multiple.toFixed(3) + 'π';
        }

        function updateTitles(phaseShift) {
            const phaseStr = formatPhaseShift(phaseShift);
            const cosPhase = Math.cos(phaseShift).toFixed(3);
            const sinPhase = (-Math.sin(phaseShift)).toFixed(3);
            const sinPhaseFlipped = (Math.sin(phaseShift)).toFixed(3); // Flipped for visual consistency

            document.getElementById('phaseShiftedCosineTitle').textContent = `cos(t + ${phaseStr})`;
            document.getElementById('nonPhaseShiftedCosineTitle').textContent = `${cosPhase}cos(t)`;
            document.getElementById('sineWaveTitle').textContent = `${sinPhaseFlipped}sin(t)`;
        }

        function createChart(canvasId, label, data, borderColor, additionalDatasets = []) {
            // Store current dataset visibility states before destroying
            if (charts[canvasId]) {
                datasetVisibility[canvasId] = {};
                charts[canvasId].data.datasets.forEach((dataset, index) => {
                    const meta = charts[canvasId].getDatasetMeta(index);
                    datasetVisibility[canvasId][index] = meta.hidden !== true;
                });
                charts[canvasId].destroy();
            }

            const ctx = document.getElementById(canvasId).getContext('2d');

            // Create the main dataset
            const mainDataset = {
                label: label,
                data: labels.map((x, i) => ({ x: x, y: data[i] })),
                borderColor: borderColor,
                borderWidth: 2,
                fill: false
            };

            // Combine main dataset with additional datasets
            const allDatasets = [mainDataset, ...additionalDatasets]; charts[canvasId] = new Chart(ctx, {
                type: 'line',
                data: {
                    datasets: allDatasets
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: {
                            display: legendVisible[canvasId],
                            position: 'top',
                            onClick: function (e, legendItem, legend) {
                                // Default legend click behavior (toggle dataset visibility)
                                const index = legendItem.datasetIndex;
                                const chart = legend.chart;
                                const meta = chart.getDatasetMeta(index);
                                meta.hidden = meta.hidden === null ? !chart.data.datasets[index].hidden : null;
                                chart.update();

                                // Store the new visibility state
                                if (!datasetVisibility[canvasId]) {
                                    datasetVisibility[canvasId] = {};
                                }
                                datasetVisibility[canvasId][index] = meta.hidden !== true;
                            }
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: canvasId === 'sineWaveChart',
                                text: 'Time (t)'
                            },
                            type: 'linear',
                            min: -Math.PI,
                            max: Math.PI,
                            ticks: {
                                stepSize: Math.PI,
                                callback: function (value) {
                                    if (Math.abs(value + Math.PI) < 0.001) return '-π';
                                    if (Math.abs(value) < 0.001) return '0';
                                    if (Math.abs(value - Math.PI) < 0.001) return 'π';
                                    return '';
                                }
                            },
                            grid: {
                                drawBorder: true,
                                color: (context) => Math.abs(context.tick.value) < 0.001 ? 'black' : 'rgba(0,0,0,0.1)',
                                lineWidth: (context) => Math.abs(context.tick.value) < 0.001 ? 2 : 1
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Amplitude'
                            },
                            min: -1.05,
                            max: 1.05,
                            ticks: {
                                stepSize: 0.5,
                                callback: function (value) {
                                    // Flip labels for sine chart to make negative values appear positive
                                    if (canvasId === 'sineWaveChart') {
                                        if (Math.abs(value + 1) < 0.11) return '1';
                                        if (Math.abs(value) < 0.11) return '0';
                                        if (Math.abs(value - 1) < 0.11) return '-1';
                                        return '';
                                    } else {
                                        if (Math.abs(value + 1) < 0.11) return '-1';
                                        if (Math.abs(value) < 0.11) return '0';
                                        if (Math.abs(value - 1) < 0.11) return '1';
                                        return '';
                                    }
                                }
                            },
                            grid: {
                                drawBorder: true,
                                color: (context) => Math.abs(context.tick.value) < 0.001 ? 'black' : 'rgba(0,0,0,0.1)',
                                lineWidth: (context) => Math.abs(context.tick.value) < 0.001 ? 2 : 1
                            }
                        }
                    }
                }
            });

            // Restore dataset visibility states
            if (datasetVisibility[canvasId]) {
                allDatasets.forEach((dataset, index) => {
                    if (datasetVisibility[canvasId][index] === false) {
                        const meta = charts[canvasId].getDatasetMeta(index);
                        meta.hidden = true;
                    }
                });
                charts[canvasId].update('none'); // Update without animation
            }
        }

        function toggleLegend(canvasId) {
            legendVisible[canvasId] = !legendVisible[canvasId];

            // Update the chart options and redraw
            if (charts[canvasId]) {
                charts[canvasId].options.plugins.legend.display = legendVisible[canvasId];
                charts[canvasId].update('none');
            }
        }

        function createComplexPlaneChart(phaseShift) {
            // Destroy existing chart if it exists
            if (charts['complexPlaneChart']) {
                charts['complexPlaneChart'].destroy();
            }

            const canvas = document.getElementById('complexPlaneChart');
            const container = canvas.parentElement;

            // Force the container to be square based on its current width
            const containerWidth = container.offsetWidth;
            container.style.height = containerWidth + 'px';

            const ctx = canvas.getContext('2d');

            // Single point representing cos(Φ) + i·sin(Φ)
            const realPart = Math.cos(phaseShift);
            const imagPart = Math.sin(phaseShift);

            // Create unit circle for reference
            const unitCirclePoints = [];
            for (let angle = 0; angle <= 2 * Math.PI; angle += Math.PI / 50) {
                unitCirclePoints.push({
                    x: Math.cos(angle),
                    y: Math.sin(angle)
                });
            }

            charts['complexPlaneChart'] = new Chart(ctx, {
                type: 'scatter',
                data: {
                    datasets: [
                        {
                            label: 'Unit Circle',
                            data: unitCirclePoints,
                            borderColor: 'rgba(128, 128, 128, 0.5)',
                            backgroundColor: 'transparent',
                            borderWidth: 1,
                            borderDash: [5, 5],
                            pointRadius: 0,
                            showLine: true,
                            fill: false
                        },
                        {
                            label: 'Projection Lines',
                            data: [
                                { x: realPart, y: 0 },        // Vertical line start (on real axis)
                                { x: realPart, y: imagPart }, // Main point
                                { x: 0, y: imagPart },        // Horizontal line start (on imaginary axis)
                                { x: realPart, y: imagPart }  // Main point again
                            ],
                            borderColor: 'rgba(0, 0, 0, 0.3)',
                            backgroundColor: 'transparent',
                            borderWidth: 1,
                            borderDash: [3, 3],
                            pointRadius: 0,
                            showLine: true,
                            fill: false,
                            segment: {
                                borderColor: (ctx) => {
                                    // Different segments for vertical and horizontal lines
                                    if (ctx.p0DataIndex === 0 && ctx.p1DataIndex === 1) return 'rgba(0, 0, 0, 0.3)'; // Vertical
                                    if (ctx.p0DataIndex === 2 && ctx.p1DataIndex === 3) return 'rgba(0, 0, 0, 0.3)'; // Horizontal
                                    return 'transparent'; // Hide connecting line
                                }
                            }
                        },
                        {
                            label: 'Real Projection',
                            data: [{ x: realPart, y: 0 }],
                            borderColor: 'blue',
                            backgroundColor: 'blue',
                            borderWidth: 2,
                            pointRadius: 6,
                            showLine: false,
                            fill: false
                        },
                        {
                            label: 'Imaginary Projection',
                            data: [{ x: 0, y: imagPart }],
                            borderColor: 'green',
                            backgroundColor: 'green',
                            borderWidth: 2,
                            pointRadius: 6,
                            showLine: false,
                            fill: false
                        },
                        {
                            label: 'e^(iΦ) = cos(Φ) + i·sin(Φ)',
                            data: [{ x: realPart, y: imagPart }],
                            borderColor: 'orange',
                            backgroundColor: 'orange',
                            borderWidth: 2,
                            pointRadius: 8,
                            showLine: false,
                            fill: false
                        }
                    ]
                },
                options: {
                    responsive: true,
                    maintainAspectRatio: false,
                    animation: false,
                    plugins: {
                        legend: {
                            display: legendVisible['complexPlaneChart'],
                            position: 'top'
                        }
                    },
                    scales: {
                        x: {
                            title: {
                                display: true,
                                text: 'Real (cos(Φ))'
                            },
                            min: -1.2,
                            max: 1.2,
                            grid: {
                                drawBorder: true,
                                color: (context) => Math.abs(context.tick.value) < 0.001 ? 'black' : 'rgba(0,0,0,0.1)',
                                lineWidth: (context) => Math.abs(context.tick.value) < 0.001 ? 2 : 1
                            }
                        },
                        y: {
                            title: {
                                display: true,
                                text: 'Imaginary (sin(Φ))'
                            },
                            min: -1.2,
                            max: 1.2,
                            grid: {
                                drawBorder: true,
                                color: (context) => Math.abs(context.tick.value) < 0.001 ? 'black' : 'rgba(0,0,0,0.1)',
                                lineWidth: (context) => Math.abs(context.tick.value) < 0.001 ? 2 : 1
                            }
                        }
                    }
                }
            });
        } function updateChartsForPhaseShift(phaseShift) {
            // Calculate waveforms
            const phaseShiftedCosine = labels.map(x => Math.cos(x + phaseShift));
            const nonPhaseShiftedCosine = labels.map(x => Math.cos(phaseShift) * Math.cos(x));
            const sineWave = labels.map(x => -Math.sin(phaseShift) * Math.sin(x));
            const decomposedSum = labels.map((x, i) => nonPhaseShiftedCosine[i] + sineWave[i]);

            // Update titles and slider display
            updateTitles(phaseShift);
            phaseShiftValue.textContent = formatPhaseShift(phaseShift);

            // Create additional dataset for decomposed sum
            const decomposedSumDataset = {
                label: 'Decomposed Sum',
                data: labels.map((x, i) => ({ x: x, y: decomposedSum[i] })),
                borderColor: 'red',
                borderWidth: 5,
                borderDash: [5, 5],
                fill: false
            };

            // Create all charts
            createChart('phaseShiftedCosineChart', 'Phase-Shifted Cosine', phaseShiftedCosine, 'orange', [decomposedSumDataset]);
            createChart('nonPhaseShiftedCosineChart', 'Non-Phase-Shifted Cosine', nonPhaseShiftedCosine, 'blue');
            createChart('sineWaveChart', 'Sine Wave', sineWave, 'green');
            createComplexPlaneChart(phaseShift);
        }

        // Initialize charts
        updateChartsForPhaseShift(phaseShift); phaseShiftSlider.addEventListener('input', () => {
            const newPhaseShift = parseFloat(phaseShiftSlider.value);
            updateChartsForPhaseShift(newPhaseShift);
        });
    </script>
</body>

</html>